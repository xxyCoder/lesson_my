# 函数
1. 理解参数
    - 无论你定义的函数有多少个参数，调用的时候传递多或少也没关系，原因是参数在内部用一个数组表示
    - 函数体内可以用arguments对象访问，下标从0开始，length表示传递进多少个参数
    - 所以，命名参数只是提供便利，但不是必须的，没有被传递值的参数为undefined
    - arguments的值永远与对应参数的值保持同步，但不是这两个值访问相同空间；它们的内存空间是独立的，但是值会保持同步
    - arguments是伪数组，没有真正数组的方法
2. 没有实现重载
    - 因为函数的参数都是用一个数组表示，而没有函数签名，所以做不到函数重载，只能被覆盖
    - 但是可以根据传入函数的参数的类型和数量做出不同的反应，可以模拟方法重载
3. 两种声明方式
    - 命名函数
        function ... () {}
    - 函数表达式
        var fun = function() {}
4. 立即调用的函数表达式
    (function() {
        // 块级作用域，即使使用了var
    })();
# es6箭头函数
- 形式 =>
- 如果只有一个参数，可以省略括号，其余情况都不能省略
- 如果不使用大括号，那么只能有一行代码，且默认返回这行代码的值
- 箭头函数不能使用arguments、super、new.target，没有prototype属性
# es6支持默认参数
- arguments对象的值不反应参数的默认值
- 箭头函数也可以有默认值，但是对于单个参数就不能省略括号了
- 后定义的参数可以引用前面的参数，但是前面的不能引用后面的，遵循暂时性死区规则 
# 扩展操作符
- 对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入
# 函数内部
- new.target
    如果函数使用了new调用，则new.target指向被调用的构造函数；如果是正常调用，则值为undefined
# 函数属性和方法
- 属性有length，表示参数个数
- 属性prototype
- 方法apply() call()，第一个参数都是this指向的值
    apply() 第二个参数可以是数组、arguments
    call() 第二个参数必须是一个一个传递进入的
# 私有变量
- JS中没有私有成员，有私有变量，即声明在函数或者块中的变量都可以认为是私有的